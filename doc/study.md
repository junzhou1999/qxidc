# qxidc | 气象数据中心项目

## 环境

* 主机：centos7，gcc、g++内置，gdb：7.8，cmake：3.14

## 配置Cmake编译

基本忘光了，课程也已经更新了，还是学回旧的课程吧

* g++ -L -l 编译选项是针对静态库来编译的
* 使用cmake编译来跟着视频走

## 使用框架的日志类打印日志

## 将文件中的数据读取到程序内的容器

* 循环读取文件一行
* 分割内容

## 生成模拟观测数据

## 将观测数据写入文件

* 创建临时文件+写入临时文件+重命名，这样能避免写入文件时其他程序读到不完整的数据
* stat 显示文件的状态，同时加上可以选择数据文件时间的选项

## 支持生成数据格式为xml

## 支持生成数据格式为json

#### 多进程避免产生僵尸进程的方法

* 处理子进程退出SIGCHLD的信号
* 忽略子进程SIGCHLD信号
* 父进程阻塞等待子进程退出发出SIGCHLD信号，一旦有一个子进程推出，父进程wait函数就返回

## 创建服务调度程序

* 多进程，父进程先退出，子进程成为孤儿进程，由系统1号进程托管
* 多进程，子进程先退出，父进程如果没有处理对子进程发出的SIGCHLD信号，则子进程成为僵尸进程占用系统进程资源

## 创建并写入一块共享内存

* ipcs -m 查看共享内存
* ipcrm -m shmid 删除共享内存

## 给共享内存加入简单的二元信号量锁

* 信号量值包括二元锁（互斥锁），用0和1表示
* 值如果表示可用资源数，可以实现生成/消费者模型，忘了。。。
* p操作或者wait操作，代表给资源上锁或用去一个资源
* v操作或者post操作，用于释放一个资源

## 测试守护进程

* 守护进程以及添加心跳信息的服务程序都要访问`共享内存`中的进程信息
* 而同时竞争访问修改同一块内存需要互斥，这时就要用上信号量了

## 定时压缩超时的数据文件

## 定时删除超时的数据文件

## 用shell脚本启动服务程序

## 配置mysql到c程序

* 配置好相关引用(库)目录，以及额外需要的cpp源码和库名，就可以编译编译了
* 还需要配置好服务器的LD_LIBRARY_PATH选项

## 使用sql语句创建一个表

## 使用sql语句插入一些数据

## 使用sql语句更新表数据

* prepare，然后绑定序号

## 使用sql语句查询表数据

* prepare->bindin/bindout->execute->next循环
* MySQL对于日期型的值，str_to_date()函数可以对其输入字符串
* date_format()可以输出字符串

## 使用sql语句删除表数据

## 输入blob二进制字段到数据库

* 注意好数据库、程序、外部文件的理解
* 框架已经封装好了，只需要把blob当作值一样写入sql语句即可

## 输出blob二进制字段到数据库

## 怎么插入空的字段

* 不指明字段插入，修改prepare sql语句不合适
* 用空字符串来插入，框架内置判别是否是MySQL的空类型
* params_in_is_null=true
* MySQL用空字符串''插入decimal类型会报错的

## 把站点数据放到数据库中

* 回顾守护进程：程序设定自己的超时时间放在共享内存
* 守护进程定时执行检测共享内存里守护进程是否超时
* 如超时，则kill掉
* 1；这个添加进数据库的操作有一个记录时间字段，记录用户插入或者更新站点数据的元组
* 2；引用了Mysql的库文件

## 把站点观测数据XML放到数据库中

* primary key (obtid, ddatetime)和IDX_ZHOBTMIND_1 (ddatetime, obtid)的区别
* where obtid=:1 and ddatetime=:2 查询时用主键
* where ddatetime=:1 and obtid=:2 查询时用索引
* statement的初始化需要connection对象，这点需要注意
* 理解好观测数据和数据库数据格式的转换

## 尝试把字符串分割和sql语句的执行封装成对象

* 注意好要封装的内容就行
* 对于日志类、数据库连接的时机这些不是封装的内容需要注意代码的书写

## 支持csv格式的文件数据入库

* 修正一些错误封装细节，比如结构体的初始化，conn对象的加载
* 同时检测csv和xml文件来支持对数据库的插入

## 定期执行sql脚本

* 内置的命令行：mysql -uroot -ppwd -Ddb_qxidc < xxx.sql
* 执行shell工具不支持输入重定向
* 所以编写一个读取sql文件然后执行这些个语句

## cmake编译ftp静态库

* 因为ftp库在clion没有可执行的入口，所以编译只能在Linux中手打
* 在任意一个 CMakeLists.txt的目录下：
* cmake --build {outputpath} [--target targetname]
* 静态库的输出目录配置在具体的CMakeLists.txt中

## ftpgetfiles:将XML参数解析到程序中

* ftp下载的检验是通过文件的时间是否相一致来判断文件正确性，同样的aaa和bbb它们的大小是一样的，无法比较
* 而服务器上传的过程保证了文件不会发生变化，那么只需要比较文件的大小就可以

## 拉取服务器的文件

* 可能会停，准备复试去了，给自己立个旗子，那就上岸把
* 虽然初试分数很低，专业课基础也不太好，那就尝试着吧

## 完善ptype传输

* ptype=2，下载完文件后删除ftp服务器的文件
* ptype=3，下载完备份文件到新的目录

## 新开一个多线程

* ps -ef查看进程编号
* ps -Lf + 进程编号，查看进程的线程信息
* LWP线程id，NLWP线程数目
* 线程拥有独立的TCB

## 线程的独立性

* 线程如果调用了exit()，出现core dump现象，或者给进程发信号
* 整个进程都会退出

## 线程退出

* pthread_exit(); pthread_calcel()，线程return

## 线程函数的参数传递

* 每个线程创建到执行的时间间隔是不一样的，有的进程快，有的进程慢
* 可以把8字节的void*当作值传给线程函数
* 也可以把具体的动态变量（int，结构体）的地址传进去，然后在线程函数里用完释放这个地址

## 接受线程函数的返回值

* pthread_join()第二个的参数就是一个8字节的void**二级指针，应把他当作8字节的空间来使用比较方便
* 只能封装当一级指针然后再取地址这样操作二级指针
* 也可以将结构体地址传来传去